<!DOCTYPE html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="remark,remarkjs,markdown,slideshow,presentation" />
<meta name="description" content="A simple, in-browser, markdown-driven slideshow tool." />

<title>Remark</title>
<link rel="stylesheet" type="text/css" href="slide.css">
</head>
<body>
<textarea id="source">
name: inverse
layout: true
class: center, middle, inverse
---
# Modal and Component-Based System Specifications
##Mikael Harkjær Møller
### Department of Computer Science, Aalborg University
[Monday, 16th of December]
???
# Welcome

---
## What is the problem?

---
layout: false
.left-column[
### Software is everywhere
]
.right-column[
Software is no longer just PC programs, and it has not been that for years.

- It is controlling indoor climate,

- helping you navigate in traffic,

- securing and letting you access you home and

- washing your clothes!
.illustration[
![x](images/software-is-everywhere.png)
]
]

---
.left-column[
### Software is everywhere
### Also in critical systems
]
.right-column[
Software is even something we need to trust with our lives, as it is also being used in safety-critical sytems.

- Software is also used in space programs,

- to steer and brake cars, trains, flights,

- and to assist air traffic controllers..

.illustration[
![x](images/also-in-critical-systems.png)
]
]

---
.left-column[
### Software is everywhere
### Also in critical systems
### But it can still break down
]
.right-column[
However, just as computer programs such systemst might crash or fail.

- Ariane 5 [1996] -- exploded after 37 seconds.

- Toyota Prius [2010] -- 100.000+ needed an ABS update.

- L.A. Air Route Traffic Control Center [2004] -- Lost all radio contact.

.illustration[
![x](images/also-in-critical-systems.png)
]

]
---
template: inverse

## What can we do about it?

---
.left-column[
### Formal Verification
]
.right-column[
Formal Verification is a class of techniques that can be used as to prove correctness of a system.

Each of them relies on three components:

- A formal specification of the system analysed.

- A set of formal requirements for the system.

- A mathematically-based method that can analyse the system and requirement.

.illustration[
![x](images/formal-verification.png)
]
]

???
Formal Methods
---
name: model-check
.left-column[
### Formal Verification
### Model Checking
]
.right-column[
Model Checking is a formal verification method, that systematically will explore all possible configurations of a system model to verify that all of them meet the given requirements.
].right-column-cont[
.model[
System
]
.spec[
Requirements
]
]
---
name:model-check2
template:model-check
.right-column-cont[
.implies[
$\downarrow$
]
.implies[
$\downarrow$
]
.model[
Model
]
.spec[
Logic Formula
]

]
---
name:model-check3
template:model-check2
.right-column-cont[
.implies[
$\downarrow$
]
.implies[
$\downarrow$
]
.model-checker[
Model Checker
]
]
---
name:model-check4
template:model-check3
.right-column-cont[
.model-checker-implies[
$\downarrow$
]
.answer[
Yes or No
]
]

---
template: inverse

## Doesn't that solve our problems?
---

.left-column[
### Abstraction
]
.right-column[
Even simple systems can have a complex logic inside. Which makes model checking hard or impossible.

- Model Checking on a abstracted model.

- Does not prove anything for the real system.

- Model must express all details of the system.

.illustration[
![x](images/abstraction.png)
.abstraction-relation[
## $\leftrightarrow$
]
]
]
???
Complexity is a major problem in model checking.
---

.left-column[
### Abstraction
### Usability
]
.right-column[
For model checking to be really helpful it should be well integrated with system development processes.

- Developing a formal system model can be time consuming.

- System specifications evolve throughout the design process.

- A design process can lead to a series of products.

.illustration[
![x](images/usability.png)
]

]

---
template: inverse

## Didn't anyone work on this before?
---
name:mts
layout:true
.left-column[
### Modal Transition Systems
]
.right-column[ 
Modal Transition Systems *(MTS)* is a modelling framework that is more suited for **model-based development**, as it support **model refinement**.


]
---
template:mts
.right-column-cont[
.mts-figure[
![x](images/tikz-0.png)
]
]
???
Loose specification
---
template:mts
.right-column-cont[
.mts-figure[
![x](images/tikz-1.png)
]
]
---
template:mts
.right-column-cont[
.mts-figure[
![x](images/tikz-2.png)
]
]
---
name:mts-prob
layout: false
.left-column[
### Modal Transition Systems
]
.right-column[
MTSs are not always precise enough. They allow too many implements as *valid* implementations.
.figure[
.car-wash-ex[
![x](images/tikz-3.png)
]
]
]
---
template:mts-prob
.right-column[
.figure[
.car-wash-imp[
![x](images/tikz-6.png)
![x](images/tikz-5.png)
![x](images/tikz-7.png)
]
]
]
---
name:dmts
layout: false
.left-column[
### Modal Transition Systems
### Disjunctive MTS
]
.right-column[
Several extensions of MTS have been introduced to address these problems. **Disjunctive Modal Transition System** is one of them.
.figure[
.car-wash-ex[
![x](images/tikz-8.png)
]
]
]
---
template:dmts
.right-column[
.figure[
.car-wash-imp[
![x](images/tikz-9.png)
![x](images/tikz-5.png)
![x](images/tikz-7.png)
]
]
]
---
name:ots-ex
layout: false
.left-column[
### Modal Transition Systems
### Disjunctive MTS
### Transition System with Obligations
]
.right-column[
Another extension is the **Transition Systems with Obligations**, where modalities are expressed by positive *logic obligations*.
.figure[
.ots-ex[
![x](images/tikz-10.png)
]
]
]
???
Only one transition relation.

We still draw must arrows as solid lines
---
template:ots-ex
.right-column[
.figure[
.car-wash-imp[
![x](images/tikz-9.png)
![x](images/tikz-5.png)
![x](images/tikz-7.png)
]
]
]
---
name: last-page
template: inverse

## So what did you do to fix this?
---
name:bmts-ex
layout: false
.left-column[
### Modal Transition Systems
### Disjunctive MTS
### Transition System with Obligations
### Boolean MTS
]
.right-column[
We started by defining **Boolean Modal Transition Systems** a simple extension of OTS. Where we allow arbitrary satisfiable boolean formulas.
.figure[
.ots-ex[
![x](images/tikz-12.png)
]
]
]
---
template:bmts-ex
.right-column[
.figure[
.car-wash-imp[
![x](images/tikz-9.png)
![x](images/tikz-11.png)
![x](images/tikz-7.png)
]
]
]
---
name:pmts-ex
layout: false
.left-column[
### Modal Transition Systems
### Disjunctive MTS
### Transition System with Obligations
### Boolean MTS
### Parametric MTS
]
.right-column[
In order to model persistence we add a set of *parameters* that can be used in the obligation functions.
.figure[
.ots-ex[
![x](images/tikz-13.png)
]
]
]
???
Paremeters can be seen as a switch you can turn on or off.
---
template:pmts-ex
.right-column[
.figure[
.car-wash-imp[
![x](images/tikz-9.png)
![x](images/tikz-11.png)
![x](images/tikz-14.png)
]
]
]
---
.left-column[
### Modal Transition Systems
### Disjunctive MTS
### Transition System with Obligations
### Boolean MTS
### Parametric MTS
]
.right-column[
.definition[
# Definition
A **parametric MTS** (PMTS) over an action alphabet $\Sigma$ is 
a tuple $(S,T,P,\Phi)$ where

- $S$ is a set of *states*
- $T \subseteq S \times \Sigma \times S$ is a *transition relation*, 
- $P$ is a finite set of parameters, and
- $\Phi : S \to \mathcal B((\Sigma \times S) \cup P)$ is a satisfiable *obligation function* over the atomic propositions containing 
outgoing transitions and parameters. 

We implicitly assume that whenever $(a,t) \in \Phi(s)$ then 
$(s,a,t) \in T$.
]
]
---
name:pmts-ex-good
layout: false
.left-column[
### Modal Transition Systems
### Disjunctive MTS
### Transition System with Obligations
### Boolean MTS
### Parametric MTS
### Modal Refinement

]
.right-column[
Modal refinement is defined along the same lines as for standard MTS. 
.figure[
.ots-ex[
![x](images/tikz-13.png)
]
]
]
---
template:pmts-ex-good
.right-column[
These are the valid implementations:
.figure[
.car-wash-imp-good[
![x](images/tikz-15.png)
![x](images/tikz-16.png)
]
]
]
???
Complexity of modal refinement from P-complete to Pi-p-4
---
name:pmts-ex-good
layout: false
.left-column[
### Modal Transition Systems
### Disjunctive MTS
### Transition System with Obligations
### Boolean MTS
### Parametric MTS
### Modal Refinement
### Logic for PMTS
]
.right-column[
Furthermore, we define a new requirement logic for PMTS, that can determine for which parameters the model will met the requirement. 

**Must** always perform a car wash:
$$ \langle \mathtt{wash} \rangle \mathbf{tt} $$

**Must** always wax car after **any** car wash:
$$ \[\mathtt{wash}\] \langle \mathtt{wax} \rangle \mathbf{tt} $$


.illustration[
  ![x](images/tikz-13.png)
]
]  
???
We define a new logic for PMTS to do this based on Hennesy Milner Logic with Recursion.
---

name: last-page
template: inverse

## That's all folks (for now)!

Slideshow created using [remark](http://github.com/gnab/remark).
</textarea>
<script src="remark-0.5.9.min.js" type="text/javascript"></script>
<script type="text/javascript"
src="MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntil=configured"></script>
<script type="text/javascript" src="jquery.min.js"></script>

<script type="text/javascript">
var hljs = remark.highlighter.engine;
</script>
<script type="text/javascript">
var slideshow = remark.create({
// highlightStyle: 'monokai',
// highlightLanguage: 'remark'
}) ;
// Setup MathJax
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$'], ['\\(','\\)']]
}
});
MathJax.Hub.Queue(function() {
$(MathJax.Hub.getAllJax()).map(function(index, elem) {
return(elem.SourceElement());
}).parent().addClass('has-jax');
});

MathJax.Hub.Configured();
</script>
</body>
</html>
